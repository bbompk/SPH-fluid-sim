<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Three.js</title>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <div class="my-ui">
        <button id="reset-btn">RESET</button>
        <button id="toggle-btn" class="paused">PLAY</button>
        <button id="tank-preset-btn">Tank Preset</button>
        <button id="plate-preset-btn">Plate Preset</button>
    </div>
    <script id="particle-vertex-shader" type="vertex">
        uniform float uParticleRadius;
        uniform int uParticleDivisions;

        attribute int aRadialIndex;

        const float PI = 3.14159265359;

        void main() {
            vec3 pos = position;
            if (aRadialIndex >= 0) {
                float angle = float(aRadialIndex) / float(uParticleDivisions) * 2.0 * PI;
                float radius = uParticleRadius;
                float x = cos(angle) * radius;
                float y = sin(angle) * radius;
                pos = vec3(x, y, 0.0);
            }
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    </script>
    <script id="particle-fragment-shader" type="fragment">
        uniform vec3 uColor;
        uniform float uOpacity;
        void main() {
            gl_FragColor = vec4(uColor, uOpacity);
        }
    </script>
    <script id="slope-vertex-shader" type="vertex">
        uniform float uSideLength;

        attribute int aPointIndex;

        void main() {
            vec3 pos = position;
            if (aPointIndex == 0) pos = vec3(0.0, 0.0, 0.0);
            if (aPointIndex == 1) pos = vec3(0.0, uSideLength, 0.0);
            if (aPointIndex == 2) pos = vec3(uSideLength, 0.0, 0.0);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    </script>
    <script id="slope-fragment-shader" type="fragment">
        uniform vec3 uColor;
        void main() {
            gl_FragColor = vec4(uColor, 1.0);
        }
    </script>
    <script id="raymarching-canvas-vertex-shader" type="vertex">
        varying vec3 vPosition;
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="raymarching-canvas-fragment-shader" type="fragment">
        varying vec3 vPosition;
        varying vec2 vUv;

        uniform vec3 uCamPos;
        uniform float uParticleRadius;
        uniform vec3 uParticlePositions[1600];
        uniform vec3 uSmoothingRadius;

        const float MAX_DIST_TO_TRAVEL = 18.0;

        float opSmoothUnion(float d1, float d2, float k) {
            float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
            return mix(d2, d1, h) - k * h * (1.0 - h);
        }

        float sdfCircle(vec2 p, vec2 c, float r) {
            return length(p-c) - r;
        }

        float map(vec3 p) {
            float minDist = 10000.0;
            for (int i = 0; i < 1600; i++) {
                float dist = length(p - uParticlePositions[i]) - uParticleRadius;
                minDist = min(minDist, dist);
            }
            return minDist;
        }
        
        float rayMarch(vec3 ro, vec3 rd, float maxDistToTravel) {
            vec3 currentPos = vec3(vUv, 0);
            float distToSdf = map(currentPos);

            return distToSdf;
        }

        vec3 render(vec2 uv) {
            vec3 color = vec3(0.0);
            vec3 rd = vec3(uv, 1.0);
            vec3 ro = uCamPos;

            float dist = rayMarch(ro, rd, MAX_DIST_TO_TRAVEL);

            if (dist < MAX_DIST_TO_TRAVEL) {
                color = vec3(1.0);
            }

            return color;
        }

        void main() {
            vec3 color = vec3(vUv, 0.0);
            color = render(vUv);
            gl_FragColor = vec4(color, 1.0);
        }
    </script>
</body>
<script src="./js/script.js" type="module"></script>
</html>